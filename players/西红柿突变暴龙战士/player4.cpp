#include <random>
#include "../include/AI.h"
#include<math.h>
#include <thread>
#include<future>
#include<vector>
#include<queue>
/* 请于 VS2019 项目属性中开启 C++17 标准：/std:c++17 */
#define commonspeed 3000
#define fastspeed 6000
#define range 4300 //射程自定义
#define skirange 8000//技能射程，自定义
#define robotalert 7000//机器人警戒范围
#define jammeralert 10000//干扰弹警戒范围
#define ll long long
#define bigrange 8000//大射程
double Acceptable_d = 14000.0;//可以接受道具距离自己的距离 lzw
#define movingTime 50
#define touxid 36000//偷袭范围=0.5*敌人与自身距离
#define cpuspeed 3000//CPU飞行速度
// 为假则play()调用期间游戏状态更新阻塞，为真则只保证当前游戏状态不会被状态更新函数与IAPI的方法同时访问
extern const bool asynchronous = false;
//全局变量在此
int moved = 0;
const double pi = acos(-1);
int birth_num = 0;
int sjamcnt = 0;
int birthplaceno;//用于记录自己是几号出生点
bool f = 0;//gather要用
const int map0_dis[50][50] = {
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 4, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};
const int map1_dis[50][50] = {
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 4, 4, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 4, 4, 4, 4, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 4, 4, 4, 4, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 0, 4, 4, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 1,
1, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 1, 4, 4, 4, 4, 4, 4, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1,
1, 0, 4, 4, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 4, 4, 0, 1,
1, 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 4, 0, 1,
1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 4, 4, 4, 1, 1, 4, 4, 4, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 4, 4, 4, 1, 1, 4, 4, 4, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
1, 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 4, 0, 1,
1, 0, 4, 4, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 4, 4, 4, 4, 4, 4, 4, 4, 1, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 4, 4, 0, 1,
1, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 1, 4, 4, 4, 4, 4, 4, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1,
1, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 0, 4, 4, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 4, 4, 4, 4, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 4, 4, 4, 4, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 4, 4, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};
const int map1_td[50][50] = {
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 1, 1, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 1,
1, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 1, 0, 0, 1, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 1,
1, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 5, 4, 5, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 3, 0, 0, 1,
1, 0, 6, 0, 6, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 5, 4, 4, 5, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 0, 6, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 5, 4, 4, 5, 0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 5, 0, 4, 4, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 0, 5, 5, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 4, 4, 0, 5, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 5, 0, 1, 1, 0, 0, 1, 1, 0, 5, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 5, 0, 2, 2, 2, 5, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 2, 2, 2, 5, 2, 2, 2, 0, 5, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 4, 2, 5, 2, 2, 2, 2, 12,2, 2, 2, 5, 2, 4, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 5, 0, 5, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 5, 0, 5, 0, 0, 0, 1,
1, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 1,
1, 0, 0, 5, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 5, 0, 5, 2, 5, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 5, 2, 5, 0, 5, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 5, 0, 0, 1,
1, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 1, 4, 5, 4, 4, 5, 4, 1, 1, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1,
1, 0, 5, 4, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 4, 5, 4, 4, 4, 4, 5, 4, 1, 2, 10,2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 4, 5, 0, 1,
1, 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 5, 2, 5, 4, 5, 4, 4, 5, 4, 5, 2, 5, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 4, 0, 1,
1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 7, 0, 0, 0, 0, 0, 2, 2, 2, 2, 4, 4, 4, 1, 1, 4, 4, 4, 2, 2, 2, 2, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 4, 4, 4, 1, 1, 4, 4, 4, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1,
1, 0, 4, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 5, 2, 5, 4, 5, 4, 4, 5, 4, 5, 2, 5, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 4, 0, 1,
1, 0, 5, 4, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 4, 5, 4, 4, 4, 4, 4, 4, 1, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 4, 5, 0, 1,
1, 0, 0, 0, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 2, 2, 2, 1, 1, 4, 5, 4, 4, 5, 4, 1, 1, 2, 9, 2, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 1,
1, 0, 0, 5, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 5, 0, 5, 2, 5, 2, 1, 1, 2, 2, 2, 2, 1, 1, 2, 5, 2, 5, 0, 5, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 5, 0, 0, 1,
1, 0, 0, 0, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 2, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 5, 2, 2, 2, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 1,
1, 0, 0, 0, 5, 0, 5, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 5, 0, 5, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 4, 4, 2, 5, 2, 2, 2, 11,2, 2, 2, 2, 5, 2, 4, 4, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 5, 0, 2, 2, 2, 5, 2, 2, 2, 0, 0, 0, 0, 0, 0, 5, 0, 1, 0, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 2, 2, 2, 5, 2, 2, 2, 0, 5, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 5, 0, 1, 1, 0, 0, 1, 1, 0, 5, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 5, 0, 4, 4, 1, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1, 1, 0, 5, 5, 0, 1, 1, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 1, 4, 4, 0, 5, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 4, 4, 1, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 5, 4, 4, 5, 0, 1, 2 ,2, 2, 2, 2, 2, 2, 2, 0, 0, 1, 4, 4, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 6, 0, 6, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 1, 0, 5, 4, 4, 5, 0, 1, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 6, 0, 6, 0, 1,
1, 0, 0, 3, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 5, 5, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 0, 0, 0, 0, 3, 0, 0, 1,
1, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 1, 0, 0, 1, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 1,
1, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 1, 1, 1, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};
const int map0_td[50][50] = {
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 5, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 2, 2, 2, 2, 2, 2, 2, 9, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 2, 2, 2, 5, 2, 2, 5, 2, 2, 2, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 5, 4, 4, 4, 5, 4, 4, 5, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 10, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 4, 4, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 1, 1, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 5, 4, 4, 4, 4, 5, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 7, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 0, 0, 0, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 5, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 1, 1, 4, 4, 4, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 5, 0, 0, 5, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 5, 0, 1, 4, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 4, 0, 0, 1,
1, 0, 0, 0, 0, 0, 5, 0, 1, 0, 5, 0, 1, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 4, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 5, 0, 6, 0, 1, 0, 0, 0, 5, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 3, 0, 5, 0, 5, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 6, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
};
bool dodgeornot = 0;
bool no_wall[180][180] = { false };
ll time_start;
int map[50][50] = { 0 };
int nearby[3][3] = { 0 };
bool map_done = 0;
int my_team_id = 0;
int alertState;
int pc = 0;
int doWallState = 0;
double dir = 0;
int map_type = 0;//0代表原图，1代表另一张图
double speed = 0;
int flag = 0;
int along_wall[8] = { 0 };//0代表向x正方向有墙,逆时针旋转。
bool in_tunnel = false;
bool near_wall = false;
bool near_conner = false;
const double eps = 5;
int source_node = 0;
int step = 0;
int pre[180] = { 0 };
THUAI5::PropType proptype;//  lzw
std::vector<int> route;
std::priority_queue<std::pair<double, int>, std::vector<std::pair<double, int> >, std::greater<std::pair<double, int> > > heap;//pair中的第一个是dist，第二个是下标。
//return true表示可以走.
bool can_move(int type) {
	if (type == 3 || type == 1)
		return false;
	else return true;
}
bool is0(double x) { return x > -eps && x < eps; }

int GetTime() {
	auto msec = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
	return msec - time_start;
}

int cnt = -1;
int head[180] = { 0 };//作为节点的表示
bool visit[180];//作为是否被访问过
int dist[180];//记录每个节点的最短距离
std::vector<int> path;//path[i][j]里的是从nodes[i]出发，到nodes[j]的最短路径上经过的点.
int near_step = 0;

double get_angle(double my_x, double my_y, double to_x, double to_y) {//统一0到2pi
	int flag;
	if (to_y == my_y && to_x > my_x) flag = 0;
	else if (to_y > my_y && to_x > my_x) flag = 1;
	else if (to_y > my_y && to_x == my_x) flag = 2;
	else if (to_y > my_y && to_x < my_x) flag = 3;
	else if (to_y == my_y && to_x < my_x) flag = 4;
	else if (to_y < my_y && to_x < my_x) flag = 5;
	else if (to_y < my_y && to_x == my_x) flag = 6;
	else if (to_y < my_y && to_x > my_x) flag = 7;
	else if (to_y == my_y && to_x == my_x) flag = 8;
	else flag = 9;
	switch (flag)
	{
	case 0: {
		return 0;
	}case 1: {
		return atan2((to_y - my_y), (to_x - my_x));
	}case 2: {
		return pi * 0.5;
	}case 3: {
		return pi - atan2((to_y - my_y), (my_x - to_x));
	}case 4: {
		return pi;
	}case 5: {
		return pi + atan2((my_y - to_y), (my_x - to_x));
	}case 6: {
		return pi * 1.5;
	}case 7: {
		return (2 * pi) - atan2((my_y - to_y), (to_x - my_x));
	}case 8: {
		return 0;
	}
	default:
		return 0;
		break;
	}
}

class Edge {
public:
	int w;//边权
	int to;//终点node
	int next;//同一起点的下一个边的下标vector
	bool vi = true;
	Edge() { w = -1; to = -1; next = -1; };
	Edge(int nw, int nto, int x) {
		w = nw;
		to = nto;
		next = head[x];
		head[x] = ++cnt;
	}
};

std::vector<Edge>edge;


class Point {
public:
	double x;
	double y;
	int cell_x;
	int cell_y;
	inline Point(int choose, double px, double py) {//type为0时是(50000,50000),type为1时是cell.
		double temp = 1.0;
		if (choose == 0) {
			x = px;
			y = py;
			cell_x = x / 1000;
			cell_y = y / 1000;
		}
		else if (choose == 1) {
			cell_x = px;
			cell_y = py;
			x = temp * 1000 * cell_x + 500;
			y = temp * 1000 * cell_y + 500;
		}
	}
	inline Point() {};
	double get_point_angle(const Point& t)const { return get_angle(x, y, t.x, t.y); }
	//注，此函数只能处理出发点和开始点都在cell中心的路径。返回true，那么就可以走，返回false会碰墙。
	bool has_wall(Point target)
	{
		int i, xt, yt, Xt, Yt;
		double k[3], b[3], xm[3], xn[3], ym[3], yn[3], errorflag[3] = { 0 };
		double xm0, ym0, xn0, yn0, xm1, ym1, xn1, yn1;
		double e = get_angle(x, y, target.x, target.y);
		//前半部分计算出三条直线方程（中心和上下边界）
		k[0] = calculateK(x, y, target.x, target.y);
		b[0] = calculateB(x, y, target.x, target.y);
		if (x - target.x == 0)errorflag[0] = 1;
		xm0 = x - 500 * sin(e);
		ym0 = y + 500 * cos(e);
		xn0 = target.x - 500 * sin(e);
		yn0 = target.y + 500 * cos(e);
		k[1] = calculateK(xm0, ym0, xn0, yn0);
		b[1] = calculateB(xm0, ym0, xn0, yn0);
		if (xm0 - xn0 == 0)errorflag[1] = 1;
		xm1 = x + 500 * sin(e);
		ym1 = y - 500 * cos(e);
		xn1 = target.x + 500 * sin(e);
		yn1 = target.y - 500 * cos(e);
		k[2] = calculateK(xm1, ym1, xn1, yn1);
		b[2] = calculateB(xm1, ym1, xn1, yn1);
		if (xm1 - xn1 == 0)errorflag[2] == 1;
		xm[0] = x;
		ym[0] = y;
		xm[1] = xm0;
		ym[1] = ym0;
		xm[2] = xm1;
		ym[2] = ym1;
		xn[0] = target.x;
		yn[0] = target.y;
		xn[1] = xn0;
		yn[1] = yn0;
		xn[2] = xn1;
		yn[2] = yn1;

		//后半部分判断三条线上有无墙体
		for (i = 0; i <= 2; i++)
		{
			if (errorflag[i] == 0)
			{
				if (xm[i] <= xn[i]) {
					for (xt = xm[i]; xt <= xn[i]; xt++)
					{
						yt = k[i] * xt + b[i];
						Xt = (xt - xt % 1000) / 1000;
						Yt = (yt - yt % 1000) / 1000;
						if (map[Xt][Yt] == 1 || map[Xt][Yt] == 3)return true;
					}
				}
				else
				{
					for (xt = xn[i]; xt <= xm[i]; xt++)
					{
						yt = k[i] * xt + b[i];
						Xt = (xt - xt % 1000) / 1000;
						Yt = (yt - yt % 1000) / 1000;
						if (map[Xt][Yt] == 1 || map[Xt][Yt] == 3)return true;
					}
				}
			}
			else
			{
				if (ym[i] <= yn[i]) {
					for (yt = ym[i]; yt <= yn[i]; yt++)
					{
						xt = xm[i];
						Xt = (xt - xt % 1000) / 1000;
						Yt = (yt - yt % 1000) / 1000;
						if (map[Xt][Yt] == 1 || map[Xt][Yt] == 3)return true;
					}
				}
				else
				{
					for (yt = yn[i]; yt <= ym[i]; yt++)
					{
						xt = xm[i];
						Xt = (xt - xt % 1000) / 1000;
						Yt = (yt - yt % 1000) / 1000;
						if (map[Xt][Yt] == 1 || map[Xt][Yt] == 3)return true;
					}
				}
			}
		}
		return false;
	}
	double calculateK(double x1, double y1, double x2, double y2)
	{
		if (x2 == x1) {
			return 0;
		}
		return(y2 - y1) / (x2 - x1);
	}
	double calculateB(double x1, double y1, double x2, double y2)
	{
		if (x2 == x1) {
			return 0;
		}
		return (x2 * y1 - x1 * y2) / (x2 - x1);
	}
	bool touch_wall() {
		if ((x - cell_x * 1000 - 500) >= eps && (y - cell_y * 1000 - 500) >= eps) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x + 1][cell_y])
				&& can_move(map[cell_x][cell_y + 1]) && can_move(map[cell_x + 1][cell_y + 1]);
		}
		else if ((x - cell_x * 1000 - 500) >= eps && (y - cell_y * 1000 - 500) <= -eps) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x + 1][cell_y])
				&& can_move(map[cell_x][cell_y - 1]) && can_move(map[cell_x + 1][cell_y - 1]);
		}
		else if ((x - cell_x * 1000 - 500) <= -eps && (y - cell_y * 1000 - 500) >= eps) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x - 1][cell_y])
				&& can_move(map[cell_x][cell_y - 1]) && can_move(map[cell_x - 1][cell_y - 1]);
		}
		else if ((x - cell_x * 1000 - 500) <= -eps && (y - cell_y * 1000 - 500) <= -eps) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x - 1][cell_y])
				&& can_move(map[cell_x][cell_y - 1]) && can_move(map[cell_x - 1][cell_y - 1]);
		}
		else if (is0((x - cell_x * 1000 - 500)) && (y - cell_y * 1000 - 500) <= -eps) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x][cell_y - 1]);
		}
		else if (is0((x - cell_x * 1000 - 500)) && (y - cell_y * 1000 - 500) >= eps) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x][cell_y + 1]);
		}
		else if ((x - cell_x * 1000 - 500) >= eps && is0((y - cell_y * 1000 - 500))) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x + 1][cell_y]);
		}
		else if ((x - cell_x * 1000 - 500) <= -eps && is0((y - cell_y * 1000 - 500))) {
			return can_move(map[cell_x][cell_y]) && can_move(map[cell_x - 1][cell_y]);
		}
		else if (is0((x - cell_x * 1000 - 500)) && is0((y - cell_y * 1000 - 500))) {
			return can_move(map[cell_x][cell_y]);
		}
	}
	Point operator+(const Point& t)const { return Point(0, x + t.x, y + t.y); }
	Point operator-(const Point& t)const { return Point(0, x - t.x, y - t.y); }
	Point operator*(const Point& t)const { return Point(0, x * t.x - y * t.y, x * t.y + y * t.x); }
	Point operator*(const double& t)const { return Point(0, x * t, y * t); }
	Point operator/(const double& t)const { return Point(0, x / t, y / t); }
	Point operator-()const { return Point(0, -x, -y); }
	double len()const { return sqrt(x * x + y * y); }//sqrt平方根
	double sqrl()const { return x * x + y * y; }
	Point operator/(const Point& t)const { return Point(0, x * t.x + y * t.y, -x * t.y + y * t.x) / t.len() / t.len(); }
	double det(const Point& t)const { return x * t.y - y * t.x; }
	double dot(const Point& t)const { return x * t.x + y * t.y; }
	double len2()const { return x * x + y * y; }
	Point unit()const { return (*this) / len(); }
	Point translate(double dir, double dis) { return Point(0, x + dis * cos(dir), y + dis * sin(dir)); }
	bool operator< (const Point& t)const { return is0(x - t.x) ? (is0(y - t.y) ? 0 : y < t.y) : x < t.x; }
	bool operator==(const Point& t)const { return is0(x - t.x) && is0(y - t.y); }
	bool operator!=(const Point& t)const { return !is0(x - t.x) || !is0(y - t.y); }
	double rad()const { return atan2(y, x); }
	Point conj()const { return Point(0, x, -y); }
	double get_distance(Point p) {
		return (pow(pow(p.x - x, 2) + pow(p.y - y, 2), 0.5));
	}
	double get_distance(int the_x, int the_y) {
		return (pow(pow(x - the_x, 2) + pow(y - the_y, 2), 0.5));
	}
}

birthplaces[8];
Point throw000(1, 13, 9);//第0个地图teamID为0的第0个丢cpu点
Point throw001(1, 13, 34);
Point throw010(1, 32, 13);
Point throw011(1, 35, 41);
Point throw100(1, 13, 4);
Point throw101(1, 13, 45);
Point throw110(1, 36, 4);
Point throw111(1, 36, 45);
Point duzh_AssPoint, duzh_FUPoint;
Point my_position;
Point move_target;
Point final_target;
Point last_position0(0, 0, 0);
Point last_position1(0, 0, 0);
Point last_position2(0, 0, 0);
Point cruise[5];
std::vector<Point> nodes;
int dijkstra(int s, int d) {
	memset(visit, 1, sizeof(visit));
	memset(dist, 0x3f3f3f3f, sizeof(dist));
	memset(pre, -1, sizeof(pre));
	while (!heap.empty()) heap.pop();
	dist[s] = 0;
	heap.push(std::make_pair(0, s));
	while (true) {
		if (heap.empty()) {
			return 0;
		}
		std::pair<int, int> temp;//第一个是距离，第二个是节点下标
		temp = heap.top();
		if (temp.second == d) return temp.first;
		heap.pop();
		if (!visit[temp.second]) continue;
		else {
			visit[temp.second] = false;
			for (int i = head[temp.second]; i != -1; i = edge[i].next) {//i是egde对应的下标
				if (dist[edge[i].to] > dist[temp.second] + edge[i].w) {
					heap.push(std::make_pair(temp.first + edge[i].w, edge[i].to));
					dist[edge[i].to] = dist[temp.second] + edge[i].w;
					pre[edge[i].to] = temp.second;
				}
			}
		}
	}
}

void getpath(int s, int d) {
	path.clear();
	path.push_back(d);
	int temp = d;
	while (pre[temp] != -1) {
		path.push_back(pre[temp]);
		temp = pre[temp];
	}

	//std::cout << "the size of the path " << path.size() << std::endl;
	//std::cout << "the size of the nodes " << nodes.size() << std::endl;
	for (int i = 0; i < path.size(); i++) {
		//std::cout << "the path is: " << path[i] << std::endl;
	}

}
void init_edge() {
	for (int i = 0; i < nodes.size(); i++) {
		for (int j = i + 1; j < nodes.size(); j++) {
			no_wall[i][j] = !nodes[i].has_wall(nodes[j]);
		}
	}
}
void get_edge() {
	edge.clear();
	cnt = -1;
	memset(head, -1, sizeof(head));
	for (int i = 0; i < nodes.size(); i++) {
		for (int j = i + 1; j < nodes.size(); j++) {
			if (i < nodes.size() - 2 && j < nodes.size() - 2) {
				if (no_wall[i][j]) {
					edge.push_back(Edge(nodes[i].get_distance(nodes[j]), j, i));
					edge.push_back(Edge(nodes[i].get_distance(nodes[j]), i, j));
				}
			}
			else {
				if (!nodes[i].has_wall(nodes[j])) {
					edge.push_back(Edge(nodes[i].get_distance(nodes[j]), j, i));
					edge.push_back(Edge(nodes[i].get_distance(nodes[j]), i, j));
				}
			}
		}
	}
}
bool get_route() {
	moved = 1;
	nodes.erase(nodes.end() - 1);
	nodes.erase(nodes.end() - 1);
	nodes.push_back(my_position);
	nodes.push_back(final_target);
	int i = nodes.size() - 1;//i is final_target
	int j = nodes.size() - 2;//j is my_position
	if (my_position.has_wall(final_target) || final_target.has_wall(my_position)) {
		//std::cout << "dij" << std::endl;
		get_edge();
		if (head[i] != -1 && head[j] != -1) {
			if (dijkstra(i, j) == 0) {
				////std::cout << "false" << std::endl;
				return false;
			}

			getpath(i, j);

			////std::cout << " the path" << std::endl;
			for (int i = 0; i < path.size(); i++) {
				////std::cout << nodes[path[i]].x << " " << nodes[path[i]].y << std::endl;
			}

			move_target = nodes[path[moved]];
			return true;
		}
		else {
			return false;
		}
	}
	else {
		//std::cout << "none" << std::endl;
		path.clear();
		path.push_back(j);
		path.push_back(i);
		move_target = nodes[path[moved]];
		return true;
	}
}
//有阻碍，返回false,没有返回true
bool get_nearby() {
	bool r = true;
	int temp = 0;
	along_wall[0] = map[my_position.cell_x + 1][my_position.cell_y];
	along_wall[1] = map[my_position.cell_x + 1][my_position.cell_y + 1];
	along_wall[2] = map[my_position.cell_x][my_position.cell_y + 1];
	along_wall[3] = map[my_position.cell_x - 1][my_position.cell_y + 1];
	along_wall[4] = map[my_position.cell_x - 1][my_position.cell_y];
	along_wall[5] = map[my_position.cell_x - 1][my_position.cell_y - 1];
	along_wall[6] = map[my_position.cell_x][my_position.cell_y - 1];
	along_wall[7] = map[my_position.cell_x + 1][my_position.cell_y - 1];
	return r;
}//有阻碍，返回false,没有返回true

class Line {
public:
	bool is_segment;//是否是线段
	double k_angle;
	Point start, end;
	Line(Point _p = Point(0, 0, 0), Point _q = Point(0, 0, 0), bool _is_segment = true) {
		start = _p;
		end = _q;
		k_angle = start.get_point_angle(end);
		is_segment = _is_segment;

	}
	Line(double px, double py, double qx, double qy, bool _is_segment = true) {
		start = Point(0, px, py);
		end = Point(0, qx, qy);
		is_segment = _is_segment;
		k_angle = start.get_point_angle(end);
	}
	Point vec() const { return start - end; }
	bool operator == (const Line& t) const { return start == t.start && end == t.end; }
	bool has(const Point& x) const {
		if (!is0(vec().det(x - start) / (x - start).len())) return false;
		if (is_segment)
		{
			return (start - x).dot(end - x) < eps;
		}
		else return true;
	}
	Line translate(double dir, double dis) { return Line(start.translate(dir, dis), end.translate(dir, dis)); }
	std::pair<Point, bool> check_wall() {
		double length = start.get_distance(end);
		int num = length / 200 - 1;
		for (int i = 0; i < num; i++) {
			Point check = start + Point(0, start.x + 50 * i * cos(k_angle), start.y + 50 * i * sin(k_angle));
			if (can_move(map[check.cell_x][check.cell_y])) continue;
			else return std::make_pair(Point(1, check.cell_x, check.cell_y), false);
		}
		return std::make_pair(end, true);
	}
};

class Robot_type {
public:
	int addlife;
	int sheild;
	int index;
	Robot_type(int the_addlife, int the_sheild, int the_index) {
		addlife = the_addlife;
		sheild = the_sheild;
		index = the_index;
	}
};

class My_api {
public:
	IAPI& api;
	bool init() {
		auto self = api.GetSelfInfo();
		last_position2 = last_position1;
		last_position1 = last_position0;
		last_position0 = my_position;
		my_position = Point(0, self->x, self->y);
		speed = 1.0 * self->speed;
		step = speed * 0.001;
		std::cout << "there is the 1 error" << std::endl;
		if (pc == 0) {
			get_map(map_done);
			init_edge();
			std::cout << "there is the 2 error" << std::endl;
			time_start = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
			final_target = cruise[4];
			std::cout << "there is the 5 error" << std::endl;
			nodes.push_back(my_position);
			nodes.push_back(final_target);
			std::cout << "there is the 6 error" << std::endl;
			get_route();
			my_team_id = self->teamID;
		}
		pc++;
		return true;
	}
	inline My_api(IAPI& api) :api(api) {};
	double change_dir();
	bool get_map(bool& done);
	void waitingForDiscuss_cpuProcess();
	void duzh_perfectTimingForTools();
	bool liyr_move();//从自身位置开始规划路径移动。
	bool duzh_directionClear(int X, int Y, int x, int y, int dir);
	void moveControl_unit_old6(bool moveable, int ourteamid, Point xunhang);
	void moveControl_unit_attacker(int ourteamid, bool moveable, Point xunhang1, Point xunhang2);
	int lizh_dodge();
	bool linzw_ifprops();
	Point propspick(Point p);
	Point touxi();
	Point gotothrowCPU();
	Point gather();
};

void My_api::moveControl_unit_attacker(int ourteamid, bool moveable, Point xunhang1, Point xunhang2) {
	int i, xt, yt;
	double attackdis, dis;
	int xunhangstate = 0;//为0代表正在前往点1，为1代表正在前往点2
	auto self = api.GetSelfInfo();
	auto Robots = api.GetRobots();
	auto Count = api.GetFrameCount();
	//首先是攻击警戒范围
	for (i = 0; i < Robots.size(); i++)
	{
		if (Robots[i]->teamID != ourteamid && Robots[i]->canMove)
		{
			xt = Robots[i]->x;
			yt = Robots[i]->y;
			dis = sqrt((self->x - xt) * (self->x - xt) + (self->y - yt) * (self->y - yt));
			attackdis = 5000;
			if (dis <= attackdis)
			{
				THUAI5::PropType myprop = self->prop;
				THUAI5::PropType hisprop = Robots[i]->prop;
				if ((myprop == THUAI5::PropType::ShieldBreaker && hisprop == THUAI5::PropType::Shield) || (hisprop != THUAI5::PropType::Shield))
				{
					api.UseProp();
					api.UseCommonSkill();
					double e = get_angle(self->x, self->y, xt, yt);
					api.Attack(e - 0.2);
					api.Attack(e + 0.2);
				}
			}
		}
	}
	if (self->x / 1000 == xunhang1.cell_x && self->y == xunhang1.cell_y)
	{
		xunhangstate = 1;
	}
	else if (self->x / 1000 == xunhang2.cell_x && self->y == xunhang2.cell_y)
	{
		xunhangstate = 0;
	}
	//下面根据能动情况进行目标地点更新
	if (!moveable)
	{
		// 情况1：捡道具
		if (linzw_ifprops()) {
			final_target = propspick(xunhang1);
			get_route();
		}
		//情况2：巡航
		else
		{
			if (xunhangstate == 0)
			{
				final_target = xunhang1;
				get_route();
			}
			else
			{
				final_target = xunhang2;
				get_route();
			}
		}
		liyr_move();//进行实际的运动
	}
};
//moveable为true时表示可以进行正常移动，每个人的巡航点不同
void My_api::moveControl_unit_old6(bool moveable, int ourteamid, Point xunhang) {
	int i, xt, yt;
	double alertdis, dis;
	double attackdis;
	//首先不管能不能动都要进行隐身判定
	auto self = api.GetSelfInfo();
	auto Robots = api.GetRobots();
	auto Count = api.GetFrameCount();

	for (i = 0; i < Robots.size(); i++) {
		if (Robots[i]->teamID != ourteamid && Robots[i]->canMove)
		{
			xt = Robots[i]->x;
			yt = Robots[i]->y;
			dis = sqrt((self->x - xt) * (self->x - xt) + (self->y - yt) * (self->y - yt));
			attackdis = 5000;
			if (dis <= attackdis)
			{
				THUAI5::PropType myprop = self->prop;
				THUAI5::PropType hisprop = Robots[i]->prop;
				if ((myprop == THUAI5::PropType::ShieldBreaker && hisprop == THUAI5::PropType::Shield) || (hisprop != THUAI5::PropType::Shield))
				{
					api.UseProp();
					double e = get_angle(self->x, self->y, xt, yt);
					api.Attack(e - 0.1);
					api.Attack(e);
					api.Attack(e + 0.1);
				}
			}
		}
		if (Robots[i]->teamID != ourteamid && Robots[i]->canMove) {
			dis = sqrt((self->x - xt) * (self->x - xt) + (self->y - yt) * (self->y - yt));
			alertdis = Robots[i]->attackRange;
			if (dis <= alertdis) {
				api.UseCommonSkill();
			}
		}
	}
	//下面根据能动情况进行目标地点更新
	if (!moveable) {
		Point temp;
		//情况0：已经到了最后1分钟需要处理战利品
		if (GetTime() >= 560000)
		{
			temp = gather();
		}
		//情况1：丢cpu
		else if (self->cpuNum > 0) {
			temp = gotothrowCPU();
		}
		// 情况2：捡道具
		else if (linzw_ifprops()) {

			temp = propspick(xunhang);
		}
		//情况3：前往巡航点（没事做的时候,比如刚出生且附近没有道具，或者刚放完Cpu且附近没有道具）
		else {
			temp = xunhang;
		}
		if (temp != final_target) {
			final_target = temp;
			get_route();
		}
		liyr_move();//进行实际的运动
	}

};

double My_api::change_dir() {
	////std::cout << "my target is " << move_target.x << " " << move_target.y << std::endl;
	dir = my_position.get_point_angle(move_target);
	////std::cout << "if the path has wall" << my_position.has_wall(move_target) << std::endl;
	double dis = my_position.get_distance(move_target);
	////std::cout << "last_positino2" << " the x is : " << last_position2.x << " the y is : " << last_position2.y << std::endl;
	////std::cout << "my_position" << " the x is : " << my_position.x << " the y is : " << my_position.y << std::endl;
	if (last_position2 == my_position) {
		////std::cout << "likely duse" << std::endl;
		int i = GetTime() % 4 + 1;
		for (i = 1; i < 5; i++) {
			i = i % 4 + 1;
			bool temp = duzh_directionClear(my_position.x, my_position.y, my_position.cell_x, my_position.cell_y, i);
			if (temp) {
				break;
			}
		}
		switch (i)
		{
		case 1: {
			api.MoveUp(50);
			break;
		};
		case 2: {
			api.MoveLeft(50);
			break;
		};
		case 3: {
			api.MoveDown(50);
			break;
		};
		case 4: {
			api.MoveRight(50);
			break;
		};
		default:
			break;
		}
		return 0;
	}
	if (dis <= speed * 0.12) {
		if (dis <= speed * 0.05) {
			//std::cout << "target is near" << std::endl;
			moved++;
			if (moved >= path.size()) {
				//std::cout << "we need to throw now!" << std::endl;
				auto props = api.GetProps();
				for (int i = 0; i < props.size(); i++) {
					Point temp(0, props[i]->x, props[i]->y);
					if (temp == my_position && !props[i]->isMoving) {
						api.Pick(props[i]->type);
					}
				}
				return (dis / speed) * 1000.0;
			}
			move_target = nodes[path[moved]];
			return (dis / speed) * 1000.0;
		}
		else {
			return 30;
		}
	}
	else {
		//std::cout << "dis is long" << std::endl;
		return 50.0;
	}
}

bool My_api::liyr_move() {
	double time = change_dir();
	//std::cout << "the time is :" << time << std::endl;
	//std::cout << "the speed is :" << speed << std::endl;
	//std::cout << "target.x is :" << move_target.x << " " << "target.y is :" << move_target.y << std::endl;
	time = std::max((int)round(time), 1);
	api.MovePlayer(time, dir);
	return true;
}

bool My_api::duzh_directionClear(int X, int Y, int x, int y, int dir)
{
	if (doWallState == 1)return false;
	if ((X - 500) % 1000 == 0)
	{
		if (dir == 2)
		{
			if (map[x][y - 1] != 1 && map[x][y - 1] != 5)return true;
			else return false;
		}

		else if (dir == 4)
		{
			if (map[x][y + 1] != 1 && map[x][y + 1] != 5)return true;
			else return false;
		}
	}
	if ((Y - 500) % 1000 == 0)
	{
		if (dir == 1)
		{
			if (map[x - 1][y] != 1 && map[x - 1][y] != 5)return true;
			else return false;
		}
		else if (dir == 3)
		{
			if (map[x + 1][y] != 1 && map[x + 1][y] != 5)return true;
			else return false;
		}
	}
	if (dir == 1)
	{
		if ((Y - 500) % 1000 < 500)
		{
			if (map[x - 1][y] != 1 && map[x - 1][y] != 5 && map[x - 1][y + 1] != 1 && map[x - 1][y + 1] != 5)return true;
			else return false;
		}
		else
		{
			if (map[x - 1][y] != 1 && map[x - 1][y] != 5 && map[x - 1][y - 1] != 1 && map[x - 1][y - 1] != 5)return true;
			else return false;
		}
	}
	else if (dir == 2)
	{
		if ((X - 500) % 1000 < 500)
		{
			if (map[x][y - 1] != 1 && map[x][y - 1] != 5 && map[x + 1][y - 1] != 1 && map[x + 1][y - 1] != 5)return true;
			else return false;
		}
		else
		{
			if (map[x][y - 1] != 1 && map[x][y - 1] != 5 && map[x - 1][y - 1] != 1 && map[x - 1][y - 1] != 5)return true;
			else return false;
		}
	}
	else if (dir == 3)
	{
		if ((Y - 500) % 1000 < 500)
		{
			if (map[x + 1][y] != 1 && map[x + 1][y] != 5 && map[x + 1][y + 1] != 1 && map[x + 1][y + 1] != 5)return true;
			else return false;
		}
		else
		{
			if (map[x + 1][y] != 1 && map[x + 1][y] != 5 && map[x + 1][y - 1] != 1 && map[x + 1][y - 1] != 5)return true;
			else return false;
		}
	}
	else if (dir == 4)
	{
		if ((X - 500) % 1000 < 500)
		{
			if (map[x][y + 1] != 1 && map[x][y + 1] != 5 && map[x + 1][y + 1] != 1 && map[x + 1][y + 1] != 5)return true;
			else return false;
		}
		else
		{
			if (map[x][y + 1] != 1 && map[x][y + 1] != 5 && map[x - 1][y + 1] != 1 && map[x - 1][y + 1] != 5)return true;
			else return false;
		}
	}
	else return false;
}

int My_api::lizh_dodge() {
	auto self = api.GetSelfInfo();//得到自己的信息
	auto Robots = api.GetRobots();//得到其他机器人的信息
	auto SignalJammers = api.GetSignalJammers();//得到场上子弹信息
	int jammer_num = 0, robot_num = 0;
	int my_break_sheild = 0;
	dodgeornot = 0;
	int spd = speed / 20;
	//以下为lzh的危险评估以及躲避函数部分：
	std::vector<int> commonjammers;
	std::vector<int> linejammers;
	std::vector<int> strongjammers;
	std::vector<int> fastjammers;
	for (int i = 0; i < SignalJammers.size(); i++) {//遍历场上所有子弹
		if (SignalJammers[i]->parentTeamID != my_team_id) {//如果是敌方子弹
			if (SignalJammers[i]->type == THUAI5::SignalJammerType::CommonJammer) {//如果是普通子弹
				if (my_position.get_distance(SignalJammers[i]->x, SignalJammers[i]->y) < (500 + spd * 10 + 350 + 2500 + 125)) {
					commonjammers.push_back(i);//加入考虑范围
				}
			}
			else if (SignalJammers[i]->type == THUAI5::SignalJammerType::LineJammer) {//如果是激光弹
				if (my_position.get_distance(SignalJammers[i]->x, SignalJammers[i]->y) < 4550 + 350 + spd * 10) {
					linejammers.push_back(i);
				}
			}
			else if (SignalJammers[i]->type == THUAI5::SignalJammerType::StrongJammer) {//如果是强力干扰弹
				if (my_position.get_distance(SignalJammers[i]->x, SignalJammers[i]->y) < (500 + spd * 10 + 7000 + 100)) {
					strongjammers.push_back(i);
				}
			}
			else if (SignalJammers[i]->type == THUAI5::SignalJammerType::FastJammer) {//如果是快速干扰弹
				if (my_position.get_distance(SignalJammers[i]->x, SignalJammers[i]->y) < (500 + spd * 10 + 1500 + 250)) {
					fastjammers.push_back(i);
				}
			}
		}
	}
	int damage = 0;
	alertState = 0;
	int min_sid = -1;
	double min_sdis = 0x7fffffff;
	sjamcnt = strongjammers.size();
	for (int i = 0; i < strongjammers.size(); i++) {//强力干扰弹优先判定
		int id = strongjammers[i];
		double dis = my_position.get_distance(SignalJammers[id]->x, SignalJammers[id]->y);
		if (dis < 7000) {//已进入强力干扰弹射程
			damage += 7000;
			if (damage + 1500 >= self->life) alertState = 2;
			else alertState = 1;
			duzh_perfectTimingForTools();

		}
		if (dis < min_sdis) {
			min_sid = id;
			min_sdis = dis;
		}
	}
	int min_lid = -1;
	double min_ldis = 0x7fffffff;
	for (int i = 0; i < linejammers.size(); i++) {//然后是激光干扰弹
		int id = linejammers[i];
		//要判断是否在激光弹爆炸范围内，首先要找出爆炸矩形的中心点
		double jamang = SignalJammers[id]->facingDirection;//激光弹角度
		int jamx = SignalJammers[id]->x, jamy = SignalJammers[id]->y;//激光弹坐标
		Point cent(0, jamx + 2000 * cos(jamang), jamy + 2000 * sin(jamang));//中心点坐标
		double k1 = tan(jamang), k2 = tan(jamang - 0.5 * pi);
		double dis1 = fabs(k1 * (double)(self->x) - (double)(self->y) - k1 * (double)(cent.x) + (double)(cent.y)) / pow(k1 * k1 + 1.0, 0.5);//计算到一条直线的距离
		double dis2 = fabs(k2 * (double)(self->x) - (double)(self->y) - k2 * (double)(cent.x) + (double)(cent.y)) / pow(k2 * k2 + 1.0, 0.5);
		if (dis1 <= 500.0 && dis2 <= 2000.0) {//在射程内
			damage += 2000;
			if (damage + 1500 >= self->life) alertState = 2;
			else alertState = 1;
			duzh_perfectTimingForTools();

		}
		if (dis1 < min_ldis) {
			min_lid = id;
			min_ldis = dis1;
		}
	}
	int min_cid = -1;
	double min_cdis = 0x7fffffff;
	for (int i = 0; i < commonjammers.size(); i++) {//最后是普通子弹
		int id = commonjammers[i];
		double dis = my_position.get_distance(SignalJammers[id]->x, SignalJammers[id]->y);
		if (dis < 2500) {
			damage += 2500;
			if (damage + 1500 >= self->life) alertState = 2;
			else alertState = 1;
			duzh_perfectTimingForTools();

		}
		if (dis < min_cdis) {
			min_cid = id;
			min_cdis = dis;
		}
	}
	int min_fid = -1;
	double min_fdis = 0x7fffffff;
	for (int i = 0; i < fastjammers.size(); i++) {
		int id = fastjammers[i];
		double dis = my_position.get_distance(SignalJammers[id]->x, SignalJammers[id]->y);
		if (dis < 1500) {
			damage += 1500;
			if (damage + 1500 >= self->life) alertState = 2;
			else alertState = 1;
			duzh_perfectTimingForTools();

		}
		if (dis < min_fdis) {
			min_fid = id;
			min_fdis = dis;
		}
	}
	//以上得到了三种子弹中分别离得最近的那个子弹，以下为躲避函数
	double dodge_angle;
	int dodge_id;
	if (min_sid != -1) {//若在某个强力干扰弹范围内
		/*dodge_id = min_sid;
		dodge_angle = SignalJammers[min_sid]->facingDirection;//get_angle(SignalJammers[min_sid]->x, SignalJammers[min_sid]->y, self->x, self->y);
		*/
		if (sjamcnt >= 2) {
			dodge_id = min_sid;
			dodge_angle = SignalJammers[min_sid]->facingDirection;
		}
		else {
			double dis = my_position.get_distance(SignalJammers[min_sid]->x, SignalJammers[min_sid]->y);
			double jan = get_angle(SignalJammers[min_sid]->x, SignalJammers[min_sid]->y, self->x, self->y);
			if (fabs(dis * cos(jan) > 1000)) {
				dodge_angle = SignalJammers[min_sid]->facingDirection;
				if (dodge_angle >= pi) dodge_angle -= pi;
				else dodge_angle += pi;
			}
			else {
				dodge_id = min_cid;
				double jamang = SignalJammers[min_sid]->facingDirection;
				dodge_angle = jamang + 0.5 * pi;
				double ang = get_angle(SignalJammers[min_sid]->x, SignalJammers[min_sid]->y, self->x, self->y);
				double deltang = fabs(ang - dodge_angle);
				if (deltang < 0.5 * pi || deltang>1.5 * pi) {
					//api.MovePlayer(50, dodge_angle);
				}
				else {
					dodge_angle = jamang - 0.5 * pi;
				}
			}
		}
	}
	else if (min_lid != -1) {//如果在某个激光弹范围内
		dodge_id = min_lid;
		double jamang = SignalJammers[min_lid]->facingDirection;
		dodge_angle = jamang + 0.5 * pi;
		double ang = get_angle(SignalJammers[min_lid]->x, SignalJammers[min_lid]->y, self->x, self->y);
		double deltang = fabs(ang - dodge_angle);
		if (deltang < 0.5 * pi || deltang>1.5 * pi) {
			//api.MovePlayer(50,dodge_angle);
		}
		else {
			dodge_angle = jamang - 0.5 * pi;
			//api.MovePlayer(50,dodge_angle);
		}
	}
	else if (min_cid != -1) {//如果只存在有威胁的普通子弹
		/*dodge_id = min_cid;
		double jamang = SignalJammers[min_cid]->facingDirection;
		dodge_angle = jamang + 0.5 * pi;
		double ang = get_angle(SignalJammers[min_cid]->x, SignalJammers[min_cid]->y, self->x, self->y);
		double deltang = fabs(ang - dodge_angle);
		if (deltang < 0.5 * pi || deltang>1.5 * pi) {
			//api.MovePlayer(50, dodge_angle);
		}
		else {
			dodge_angle = jamang - 0.5 * pi;
			//api.MovePlayer(50, dodge_angle);
		}*/
		dodge_id = min_cid;
		dodge_angle = SignalJammers[min_cid]->facingDirection;//get_angle(SignalJammers[min_cid]->x, SignalJammers[min_cid]->y, self->x, self->y);
	}
	else if (min_fid != -1) {
		//dodge_id = min_fid;
		//dodge_angle = SignalJammers[min_fid]->facingDirection;//get_angle(SignalJammers[min_fid]->x, SignalJammers[min_fid]->y, self->x, self->y);
		double dis = my_position.get_distance(SignalJammers[min_fid]->x, SignalJammers[min_fid]->y);
		double jan = get_angle(SignalJammers[min_fid]->x, SignalJammers[min_fid]->y, self->x, self->y);
		if (fabs(dis * cos(jan) > 1000)) {
			dodge_angle = SignalJammers[min_fid]->facingDirection;
			if (dodge_angle >= pi) dodge_angle -= pi;
			else dodge_angle += pi;
		}
		else {
			dodge_id = min_cid;
			double jamang = SignalJammers[min_fid]->facingDirection;
			dodge_angle = jamang + 0.5 * pi;
			double ang = get_angle(SignalJammers[min_fid]->x, SignalJammers[min_fid]->y, self->x, self->y);
			double deltang = fabs(ang - dodge_angle);
			if (deltang < 0.5 * pi || deltang>1.5 * pi) {
				//api.MovePlayer(50, dodge_angle);
			}
			else {
				dodge_angle = jamang - 0.5 * pi;
			}
		}
	}
	if (alertState != 0) {
		while (dodge_angle > 2 * pi) {
			dodge_angle = dodge_angle - 2 * pi;
		}
		while (dodge_angle < 0) {
			dodge_angle = dodge_angle + 2 * pi;
		}
		//double ang = get_angle(SignalJammers[dodge_id]->x, SignalJammers[dodge_id]->y, self->x, self->y);
		//ll galx, galy;
		//galx = self->x + 200 * cos(dodge_angle), galy = self->y + 200 * sin(dodge_angle);
		//Point gal(0, galx, galy);
		//int cgalx = gal.cell_x, cgaly = gal.cell_y;
		int wall[8] = {};

		if (map[my_position.cell_x + 1][my_position.cell_y] == 1) wall[0] = 1;//右
		if (map[my_position.cell_x + 1][my_position.cell_y + 1] == 1) wall[1] = 1;//右上
		if (map[my_position.cell_x][my_position.cell_y + 1] == 1) wall[2] = 1;//上
		if (map[my_position.cell_x - 1][my_position.cell_y + 1] == 1) wall[3] = 1;//左上
		if (map[my_position.cell_x - 1][my_position.cell_y] == 1) wall[4] = 1;//左
		if (map[my_position.cell_x - 1][my_position.cell_y - 1] == 1) wall[5] = 1;//左下
		if (map[my_position.cell_x][my_position.cell_y - 1] == 1) wall[6] = 1;//下
		if (map[my_position.cell_x + 1][my_position.cell_y - 1] == 1) wall[7] = 1;//右下
		if (dodge_angle < 0.25 * pi && dodge_angle >= 0) {
			if (wall[0] == 1) {
				if (wall[2] == 1) dodge_angle = 1.5 * pi;
				else dodge_angle = 0.5 * pi;
			}
			else if (wall[1] == 1) {
				dodge_angle = 0;
			}
		}
		else if (dodge_angle < 0.5 * pi && dodge_angle >= 0.25 * pi) {
			if (wall[2] == 1) {
				if (wall[0] == 1) dodge_angle = pi;
				else dodge_angle = 0;
			}
			else if (wall[1] == 1) {
				dodge_angle = 0.5 * pi;
			}
		}
		else if (dodge_angle < 0.75 * pi && dodge_angle >= 0.5 * pi) {
			if (wall[2] == 1) {
				if (wall[4] == 1) dodge_angle = 0;
				else dodge_angle = pi;
			}
			else if (wall[3] == 1) {
				dodge_angle = 0.5 * pi;
			}
		}
		else if (dodge_angle < pi && dodge_angle >= 0.75 * pi) {
			if (wall[4] == 1) {
				if (wall[2] == 1) dodge_angle = 1.5 * pi;
				else dodge_angle = 0.5 * pi;
			}
			else if (wall[3] == 1) {
				dodge_angle = pi;
			}
		}
		else if (dodge_angle < 1.25 * pi && dodge_angle >= pi) {
			if (wall[4] == 1) {
				if (wall[6] == 1) dodge_angle = 0.5 * pi;
				else dodge_angle = 1.5 * pi;
			}
			else if (wall[5] == 1) {
				dodge_angle = pi;
			}
		}
		else if (dodge_angle < 1.5 * pi && dodge_angle >= 1.25 * pi) {
			if (wall[6] == 1) {
				if (wall[4] == 1) dodge_angle = 0;
				else dodge_angle = pi;
			}
			else if (wall[5] == 1) {
				dodge_angle = 1.5 * pi;
			}
		}
		else if (dodge_angle < 1.75 * pi && dodge_angle >= 1.5 * pi) {
			if (wall[6] == 1) {
				if (wall[0] == 1) dodge_angle = pi;
				else dodge_angle = 0;
			}
			else if (wall[7] == 1) {
				dodge_angle = 1.5 * pi;
			}
		}
		else if (dodge_angle < 2 * pi && dodge_angle >= 1.75 * pi) {
			if (wall[0] == 1) {
				if (wall[6] == 1) dodge_angle = 0.5 * pi;
				else dodge_angle = 1.5 * pi;
			}
			else if (wall[7] == 1) {
				dodge_angle = 0;
			}
		}
		api.MovePlayer(50, dodge_angle);
		dodgeornot = true;
	}
	return 0;
}


void My_api::duzh_perfectTimingForTools() {
	auto self = api.GetSelfInfo();
	THUAI5::PropType myToolType = self->prop;
	//考虑当前危险等级
	//0级考虑CPU操作
	if (alertState == 0) {}
	//1级使用加速器，护盾
	else if (alertState == 1)
	{
		if (myToolType == THUAI5::PropType(1) || myToolType == THUAI5::PropType(4))
		{
			api.UseProp();
		}
	}
	//2级使用春哥，护盾,CPU，加速器
	else if (alertState == 2)
	{
		if (myToolType == THUAI5::PropType(1) || myToolType == THUAI5::PropType(2) || myToolType == THUAI5::PropType(4))
		{
			api.UseProp();
		}
		else if (myToolType == THUAI5::PropType(3))
		{
			waitingForDiscuss_cpuProcess();
		}
	}

}

void My_api::waitingForDiscuss_cpuProcess() {
	auto self = api.GetSelfInfo();
	int myCpu = self->cpuNum;
	api.UseCPU(myCpu);
}

bool My_api::linzw_ifprops() {
	auto self = api.GetSelfInfo();
	auto Props = api.GetProps();
	if (!Props.size()) {
		//std::cout << "props" << "false" << std::endl;
		return false;
	}
	else {
		for (int i = 0; i < Props.size(); i++) {
			Point props(0, Props[i]->x, Props[i]->y);
			double d = props.get_distance(my_position);
			if (d > Acceptable_d)
				continue;
			else {
				//std::cout << "props" << "true" << std::endl;
				return true;
			}
		}
		//std::cout << "props" << "false" << std::endl;
		return false;
	}
}
//返回true,不行.
bool if_in_birth(Point p) {
	for (int i = 0; i < 8; i++) {
		//std::cout << "the ith is :" << i << " ";
		//std::cout << "the cell_x is: " << birthplaces[i].cell_x << 
			//" the cell_y is: " << birthplaces[i].cell_y << std::endl;
	}
	for (int i = 0; i < 8; i++) {
		if (p.cell_x == birthplaces[i].cell_x && p.cell_y == birthplaces[i].cell_y) {
			//std::cout << "the p.x is :" << p.x << "the p.y is :" << p.y << std::endl;
			//std::cout << "true" << std::endl;
			return true;
		}
	}
	//std::cout << "the p.x is :" << p.x << "the p.y is :" << p.y << std::endl;
	//std::cout << "false" << std::endl;
	return false;
}
bool in_tree(Point p) {
	if (p.cell_x >= 40 && p.cell_x <= 42) {
		if (p.cell_y == 10) {
			return true;
		}
	}
	return false;
}
Point My_api::propspick(Point p) {
	auto self = api.GetSelfInfo();
	auto Props = api.GetProps();
	double dmin = 10000000;
	double mini;
	if (!Props.size())//如果没有道具
		return p;
	else if (self->prop == THUAI5::PropType::Booster) {
		if (speed < 10000)
			api.UseProp();//有加速直接用
		for (int i = 0; i < Props.size(); i++) {
			Point props(0, Props[i]->x, Props[i]->y);
			double d = props.get_distance(my_position);
			if (d + d * (Props[i]->type != THUAI5::PropType::CPU) < dmin) {
				dmin = d;
				mini = i;
			}
		}
		Point props(0, Props[mini]->x, Props[mini]->y);
		if (Props[mini]->type == THUAI5::PropType::CPU) {
			//std::cout << "we have Booster and go to cpu" << std::endl;
			if (dmin > 2 * Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			else {
				proptype = Props[mini]->type;
				return props;
			}
		}
		else {
			return p;
		}
	}
	else if (self->prop == THUAI5::PropType::Battery) {
		for (int i = 0; i < Props.size(); i++) {
			Point props(0, Props[i]->x, Props[i]->y);
			double d = props.get_distance(my_position);
			if (d + d * (Props[i]->type != THUAI5::PropType::CPU) < dmin) {
				dmin = d;
				mini = i;
			}
		}
		Point props(0, Props[mini]->x, Props[mini]->y);
		if (Props[mini]->type == THUAI5::PropType::CPU) {
			if (dmin > 2 * Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			proptype = Props[mini]->type;
			return props;
		}
		else if (Props[mini]->type == THUAI5::PropType::Booster) {
			if (dmin < 1000) {
				api.UseProp();
			}
			if (dmin > Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			proptype = Props[mini]->type;
			return props;
		}
		else
			return p;
	}
	else if (self->prop == THUAI5::PropType::Shield) {
		for (int i = 0; i < Props.size(); i++) {
			Point props(0, Props[i]->x, Props[i]->y);
			double d = props.get_distance(my_position);
			if (d + d * (Props[i]->type != THUAI5::PropType::CPU) < dmin) {
				dmin = d;
				mini = i;
			}
		}
		Point props(0, Props[mini]->x, Props[mini]->y);
		if (Props[mini]->type == THUAI5::PropType::CPU) {
			if (dmin > 2 * Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			else {
				proptype = Props[mini]->type;
				return props;
			}
		}
		else if (Props[mini]->type == THUAI5::PropType::Battery || Props[mini]->type == THUAI5::PropType::Booster) {
			if (dmin < 1000) {
				api.UseProp();
			}
			if (dmin > Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			proptype = Props[mini]->type;
			return props;
		}
		else
			return p;
	}
	else if (self->prop == THUAI5::PropType::ShieldBreaker) {
		for (int i = 0; i < Props.size(); i++) {
			Point props(0, Props[i]->x, Props[i]->y);
			double d = props.get_distance(my_position);
			if (d + d * (Props[i]->type != THUAI5::PropType::CPU) < dmin) {
				dmin = d;
				mini = i;
			}
		}
		Point props(0, Props[mini]->x, Props[mini]->y);
		if (Props[mini]->type == THUAI5::PropType::CPU) {
			if (dmin > 2 * Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;

			proptype = Props[mini]->type;
			return props;
		}
		else if (Props[mini]->type == THUAI5::PropType::Battery || Props[mini]->type == THUAI5::PropType::Booster || Props[mini]->type == THUAI5::PropType::Shield) {
			if (dmin < 1000) {
				api.UseProp();
			}
			if (dmin > Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			proptype = Props[mini]->type;
			return props;
		}
		else
			return p;
	}
	else {
		for (int i = 0; i < Props.size(); i++) {
			Point props(0, Props[i]->x, Props[i]->y);
			double d = props.get_distance(my_position);
			if (d + d * (Props[i]->type != THUAI5::PropType::CPU) < dmin) {
				dmin = d;
				mini = i;
			}
		}
		Point props(0, Props[mini]->x, Props[mini]->y);
		if (Props[mini]->type == THUAI5::PropType::CPU) {
			if (dmin > 2 * Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;
			proptype = Props[mini]->type;
			return props;
		}
		else {
			if (dmin > Acceptable_d || Props[mini]->isMoving || if_in_birth(props) || in_tree(props))
				return p;

			proptype = Props[mini]->type;
			return props;
		}
		return p;
	}
}

Point My_api::touxi() {
	auto robot = api.GetRobots();
	for (int i = 0; i < robot.size(); i++) {
		if (robot[i]->teamID == my_team_id)
			continue;
		else {
			if (robot[i]->life > 6000)
				continue;
			else {
				double x = robot[i]->x;
				double y = robot[i]->y;
				Point rob(0, x, y);
				return rob;
			}
		}
	}
	return my_position;
}

Point My_api::gotothrowCPU() {
	auto self = api.GetSelfInfo();
	double d0;
	double d1;
	double an;
	Point my_position(0, self->x, self->y);
	if (map_type == 0) {
		if (self->teamID == 0) {
			//std::cout << "we will throw" << std::endl;
			d0 = my_position.get_distance(throw000);
			d1 = my_position.get_distance(throw001);
			if (d0 < d1) {
				if (d0 < 500) {
					Point a(1, 4, 7);
					an = my_position.get_point_angle(a);

					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw000;
			}
			else {
				if (d1 < 500) {
					Point a(1, 4, 29);
					an = my_position.get_point_angle(a);

					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw001;
			}
		}
		else {
			d0 = my_position.get_distance(throw010);
			d1 = my_position.get_distance(throw011);
			if (d0 < d1) {
				if (d0 < 500) {
					Point a(1, 44, 18);
					an = my_position.get_point_angle(a);

					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw010;
			}
			else {
				if (d1 < 500) {
					Point a(1, 44, 40);
					an = my_position.get_point_angle(a);
					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw011;
			}
		}
	}
	else {
		if (self->teamID == 0) {
			d0 = my_position.get_distance(throw100);
			d1 = my_position.get_distance(throw101);
			if (d0 < d1) {
				if (d0 < 500) {
					Point a(1, 3, 6);
					an = my_position.get_point_angle(a);

					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw100;
			}
			else {
				if (d1 < 500) {
					Point a(1, 3, 43);
					an = my_position.get_point_angle(a);

					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw101;
			}
		}
		else {
			d0 = my_position.get_distance(throw110);
			d1 = my_position.get_distance(throw111);
			if (d0 < d1) {
				if (d0 < 500) {
					Point a(1, 46, 6);
					an = my_position.get_point_angle(a);
					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw110;
			}
			else {
				if (d1 < 500) {
					Point a(1, 46, 43);
					an = my_position.get_point_angle(a);
					double d = my_position.get_distance(a);
					api.ThrowCPU(d / cpuspeed * 1000, an, self->cpuNum);
				}
				return throw111;
			}
		}
	}
}

Point My_api::gather() {
	auto self = api.GetSelfInfo();
	Point my_position(0, self->x, self->y);
	Point b(1, birthplaces[1].cell_x - 1, birthplaces[1].cell_y);
	double t1 = birthplaces[0].get_distance(b);
	double an1 = birthplaces[0].get_point_angle(b);
	double t2 = birthplaces[2].get_distance(b);
	double an2 = birthplaces[2].get_point_angle(b);
	if (map_type == 0) {
		if (birthplaceno == 0) {
			if (birthplaces[0].cell_x == my_position.cell_x && birthplaces[0].cell_y == my_position.cell_y) {
				api.Pick(THUAI5::PropType::CPU);
				api.ThrowCPU(1000 * t1 / cpuspeed, an1, self->cpuNum);
			}
			return birthplaces[0];
		}
		else if (birthplaceno == 1) {
			api.Pick(THUAI5::PropType::CPU);
			return b;
		}
		else if (birthplaceno == 2) {
			if (birthplaces[2].cell_x == my_position.cell_x && birthplaces[2].cell_y == my_position.cell_y) {
				api.Pick(THUAI5::PropType::CPU);
				api.ThrowCPU(1000 * t2 / cpuspeed, an2, self->cpuNum);
			}
			return birthplaces[2];
		}
		else if (birthplaceno == 3) {
			return my_position;
		}
		else if (birthplaceno == 4) {
			return my_position;
		}
		else if (birthplaceno == 5) {
			auto props = api.GetProps();
			for (int i = 0; i < props.size(); i++) {
				Point temp(0, props[i]->x, props[i]->y);
				if (temp.cell_x == birthplaces[5].cell_x && temp.cell_y == birthplaces[5].cell_y && !props[i]->isMoving) {
					api.Pick(props[i]->type);
				}
			}
			if (birthplaces[5].cell_x == my_position.cell_x && birthplaces[5].cell_y == my_position.cell_y && self->cpuNum) {
				api.ThrowCPU(my_position.get_distance(birthplaces[6]) / cpuspeed * 1000, pi / 2 + 0.013, self->cpuNum);
			}
			return birthplaces[2];
		}
		else if (birthplaceno == 6) {
			auto props = api.GetProps();
			for (int i = 0; i < props.size(); i++) {
				Point temp(0, props[i]->x, props[i]->y);
				if (temp.cell_x == birthplaces[6].cell_x && temp.cell_y == birthplaces[6].cell_y) {
					api.Pick(THUAI5::PropType::CPU);
				}
			}
			return birthplaces[6];
		}
		else {
			auto props = api.GetProps();
			for (int i = 0; i < props.size(); i++) {
				Point temp(0, props[i]->x, props[i]->y);
				if (temp.cell_x == birthplaces[1].cell_x && temp.cell_y == birthplaces[1].cell_y && !props[i]->isMoving) {
					api.Pick(props[i]->type);
				}
			}
			if (birthplaces[7].cell_x == my_position.cell_x && birthplaces[7].cell_y == my_position.cell_y && self->cpuNum) {
				api.ThrowCPU(my_position.get_distance(birthplaces[6]) / cpuspeed * 1000, 3 * pi / 2 - 0.013, self->cpuNum);
			}
			return birthplaces[7];
		}
	}
	else {
		Point p(1, 3, 40);
		Point q(1, 46, 40);
		if (birthplaceno == 0) {
			if (birthplaces[0].cell_x == my_position.cell_x && birthplaces[0].cell_y == my_position.cell_y) {
				auto props = api.GetProps();
				for (int i = 0; i < props.size(); i++) {
					Point temp(0, props[i]->x, props[i]->y);
					if (temp.cell_x == birthplaces[0].cell_x && temp.cell_y == birthplaces[0].cell_y && !props[i]->isMoving) {
						api.Pick(props[i]->type);
					}
				}
				f = 1;
				return p;
			}
			if (p.cell_x == my_position.cell_x && p.cell_y == my_position.cell_y) {
				api.ThrowCPU(1000, pi / 2 + 0.013, self->cpuNum);
				return birthplaces[0];
			}
			if (f) {
				return p;
			}
			return birthplaces[0];
		}
		else if (birthplaceno == 1) {
			auto props = api.GetProps();
			for (int i = 0; i < props.size(); i++) {
				Point temp(0, props[i]->x, props[i]->y);
				if (temp.cell_x == birthplaces[1].cell_x && temp.cell_y == birthplaces[1].cell_y && !props[i]->isMoving) {
					api.Pick(props[i]->type);
				}
			}
			return birthplaces[1];
		}
		else if (birthplaceno == 6) {
			if (birthplaces[6].cell_x == my_position.cell_x && birthplaces[6].cell_y == my_position.cell_y) {
				auto props = api.GetProps();
				for (int i = 0; i < props.size(); i++) {
					Point temp(0, props[i]->x, props[i]->y);
					if (temp.cell_x == birthplaces[6].cell_x && temp.cell_y == birthplaces[6].cell_y && !props[i]->isMoving) {
						api.Pick(props[i]->type);
					}
				}
				f = 1;
				return q;
			}
			if (f) {
				return q;
			}
			if (q.cell_x == my_position.cell_x && q.cell_y == my_position.cell_y) {
				api.ThrowCPU(1000, pi / 2, self->cpuNum);
				return birthplaces[6];
			}
			return birthplaces[6];
		}
		else if (birthplaceno == 7) {
			auto props = api.GetProps();
			for (int i = 0; i < props.size(); i++) {
				Point temp(0, props[i]->x, props[i]->y);
				if (temp.cell_x == birthplaces[7].cell_x && temp.cell_y == birthplaces[7].cell_y && !props[i]->isMoving) {
					api.Pick(props[i]->type);
				}
			}
			return birthplaces[7];
		}
		else
			return my_position;
	}
}
//s是起点
bool My_api::get_map(bool& done) {//应当记录一下各个区域的位置。
	if (done) return true;
	else {
		std::cout << "there is the 3 error" << std::endl;
		if (api.GetPlaceType(4, 24) == THUAI5::PlaceType::Wall) {
			Acceptable_d = 24000;
			map_type = 1;
			memcpy(map, map1_dis, sizeof(map1_dis));
			////std::cout << "map1" << std::endl;
			map[my_position.cell_x][my_position.cell_y] = 0;
			for (int i = 0; i < 50; i++) {
				for (int j = 0; j < 50; j++) {
					if (map1_td[i][j] == 5) {
						if (!can_move(map[i + 1][j + 1])) {
							Point temp(1, i, j);
							temp.x -= 6;
							temp.y -= 6;
							nodes.push_back(temp);
						}
						else if (!can_move(map[i + 1][j - 1])) {
							Point temp(1, i, j);
							temp.x -= 6;
							temp.y += 6;
							nodes.push_back(temp);
						}
						else if (!can_move(map[i - 1][j + 1])) {
							Point temp(1, i, j);
							temp.x += 6;
							temp.y -= 6;
							nodes.push_back(temp);
						}
						else if (!can_move(map[i - 1][j - 1])) {
							Point temp(1, i, j);
							temp.x += 6;
							temp.y += 6;
							nodes.push_back(temp);
						}
					}
					else if (map1_td[i][j] == 6) {
						if ((i != my_position.cell_x + 1) && (j != my_position.cell_y + 1)
							&& (i != my_position.cell_x - 1) && (j != my_position.cell_y - 1)) {
							if (!can_move(map[i + 1][j + 1])) {
								Point temp(1, i, j);
								temp.x -= 6;
								temp.y -= 6;
								nodes.push_back(temp);
							}
							else if (!can_move(map[i + 1][j - 1])) {
								Point temp(1, i, j);
								temp.x -= 6;
								temp.y += 6;
								nodes.push_back(temp);
							}
							else if (!can_move(map[i - 1][j + 1])) {
								Point temp(1, i, j);
								temp.x += 6;
								temp.y -= 6;
								nodes.push_back(temp);
							}
							else if (!can_move(map[i - 1][j - 1])) {
								Point temp(1, i, j);
								temp.x += 6;
								temp.y += 6;
								nodes.push_back(temp);
							}
						}
					}
					else if (map1_td[i][j] == 3) {
						birthplaces[birth_num] = Point(1, i, j);
						if (my_position.cell_x == i && my_position.cell_y == j) {
							birthplaceno = birth_num;
						}
						birth_num++;
					}
					else if (map1_td[i][j] == 7) {
						cruise[2] = Point(1, i, j);
					}
					else if (map1_td[i][j] == 8) {
						cruise[4] = Point(1, i, j);
					}
					else if (map1_td[i][j] == 9) {
						cruise[0] = Point(1, i, j);
					}
					else if (map1_td[i][j] == 10) {
						cruise[1] = Point(1, i, j);
					}
					else if (map1_td[i][j] == 11 && my_team_id) {
						cruise[3] = Point(1, i, j);
					}
					else if (map1_td[i][j] == 12 && !my_team_id) {
						cruise[3] = Point(1, i, j);
					}
				}
			}
		}
		else {
			memcpy(map, map0_dis, sizeof(map0_dis));
			////std::cout << "map0" << std::endl;
			map_type = 0;
			map[my_position.cell_x][my_position.cell_y] = 0;
			for (int i = 0; i < 50; i++) {
				for (int j = 0; j < 50; j++) {
					if (true) {
						if (map0_td[i][j] == 5) {
							if (!can_move(map[i + 1][j + 1])) {
								Point temp(1, i, j);
								temp.x -= 6;
								temp.y -= 6;
								nodes.push_back(temp);
							}
							else if (!can_move(map[i + 1][j - 1])) {
								Point temp(1, i, j);
								temp.x -= 6;
								temp.y += 6;
								nodes.push_back(temp);
							}
							else if (!can_move(map[i - 1][j + 1])) {
								Point temp(1, i, j);
								temp.x += 6;
								temp.y -= 6;
								nodes.push_back(temp);
							}
							else if (!can_move(map[i - 1][j - 1])) {
								Point temp(1, i, j);
								temp.x += 6;
								temp.y += 6;
								nodes.push_back(temp);
							}
						}
						else if (map0_td[i][j] == 6) {
							if ((i != my_position.cell_x + 1) && (j != my_position.cell_y + 1)
								&& (i != my_position.cell_x - 1) && (j != my_position.cell_y - 1)) {
								if (!can_move(map[i + 1][j + 1])) {
									Point temp(1, i, j);
									temp.x -= 6;
									temp.y -= 6;
									nodes.push_back(temp);
								}
								else if (!can_move(map[i + 1][j - 1])) {
									Point temp(1, i, j);
									temp.x -= 6;
									temp.y += 6;
									nodes.push_back(temp);
								}
								else if (!can_move(map[i - 1][j + 1])) {
									Point temp(1, i, j);
									temp.x += 6;
									temp.y -= 6;
									nodes.push_back(temp);
								}
								else if (!can_move(map[i - 1][j - 1])) {
									Point temp(1, i, j);
									temp.x += 6;
									temp.y += 6;
									nodes.push_back(temp);
								}
							}
						}
						else if (map0_td[i][j] == 3) {
							birthplaces[birth_num] = Point(1, i, j);
							if (my_position.cell_x == i && my_position.cell_y == j) {
								birthplaceno = birth_num;
							}
							birth_num++;
						}
						else if (map0_td[i][j] == 7) {
							cruise[2] = Point(1, i, j);
						}
						else if (map0_td[i][j] == 8) {
							cruise[3] = Point(1, i, j);
						}
						else if (map0_td[i][j] == 9) {
							cruise[4] = Point(1, i, j);
						}
						else if (map0_td[i][j] == 10) {
							cruise[0] = Point(1, i, j);
						}
						else if (map0_td[i][j] == 11) {
							cruise[1] = Point(1, i, j);
						}
					}
				}

			}
		}
		std::cout << "there is the 4 error" << std::endl;
		////std::cout << "nodes is all okk" << std::endl;
		////std::cout << "dij is okk" << std::endl;
		////std::cout << "path is okk" << std::endl;
		done = true;
		return true;

	}
};

// 选手主动技能，选手 !!必须!! 定义此变量来选择主动技能
extern const THUAI5::SoftwareType playerSoftware = THUAI5::SoftwareType::Invisible;

// 选手被动技能，选手 !!必须!! 定义此变量来选择被动技能
extern const THUAI5::HardwareType playerHardware = THUAI5::HardwareType::EnergyConvert;

namespace
{
	[[maybe_unused]] std::uniform_real_distribution<double> direction(0, 2 * 3.1415926);
	[[maybe_unused]] std::default_random_engine e{ std::random_device{}() };
}

void AI::play(IAPI& api) {
	My_api mapi(api);
	mapi.init();
	mapi.lizh_dodge();
	if (birthplaceno == 0 || birthplaceno == 4)
	{
		mapi.moveControl_unit_old6(dodgeornot, my_team_id, cruise[2]);
	}
	else if (birthplaceno == 1 || birthplaceno == 2 || birthplaceno == 5 || birthplaceno == 6)
	{
		mapi.moveControl_unit_old6(dodgeornot, my_team_id, cruise[3]);
	}
	else if (birthplaceno == 3 || birthplaceno == 7)
	{
		mapi.moveControl_unit_old6(dodgeornot, my_team_id, cruise[4]);
	}
}
